"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class Packet {
    constructor() {
        this.data = [];
    }
    static from(socket) {
        return __awaiter(this, void 0, void 0, function* () {
            const length = yield socket.readVarInt();
            if (length < 1) {
                return new Packet();
            }
            const data = yield socket.readBytes(length);
            const packet = new Packet();
            packet.data = data;
            return packet;
        });
    }
    readByte() {
        if (this.data.length < 1) {
            throw new Error('Cannot readByte() as buffer is empty');
        }
        return this.data.shift() || 0;
    }
    readBytes(length) {
        if (this.data.length < 1) {
            throw new Error('Cannot readByte() as buffer is empty');
        }
        return this.data.splice(0, length);
    }
    writeByte(...values) {
        this.data.push(...values);
    }
    readShortBE() {
        if (this.data.length < 2) {
            throw new Error('Cannot readShort() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(2));
        return buf.readInt16BE();
    }
    writeShortBE(value) {
        const buf = Buffer.alloc(2);
        buf.writeInt16BE(value);
        this.writeByte(...buf);
    }
    readShortLE() {
        if (this.data.length < 2) {
            throw new Error('Cannot readShortLE() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(2));
        return buf.readInt16LE();
    }
    writeShortLE(value) {
        const buf = Buffer.alloc(2);
        buf.writeInt16LE(value);
        this.writeByte(...buf);
    }
    readUShortBE() {
        if (this.data.length < 2) {
            throw new Error('Cannot readShort() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(2));
        return buf.readUInt16BE();
    }
    writeUShortBE(value) {
        const buf = Buffer.alloc(2);
        buf.writeUInt16BE(value);
        this.writeByte(...buf);
    }
    readUShortLE() {
        if (this.data.length < 2) {
            throw new Error('Cannot readUShortLE() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(2));
        return buf.readUInt16LE();
    }
    writeUShortLE(value) {
        const buf = Buffer.alloc(2);
        buf.writeUInt16LE(value);
        this.writeByte(...buf);
    }
    readIntBE() {
        if (this.data.length < 4) {
            throw new Error('Cannot readInt() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(4));
        return buf.readInt32BE();
    }
    writeIntBE(value) {
        const buf = Buffer.alloc(4);
        buf.writeInt32BE(value);
        this.writeByte(...buf);
    }
    readIntLE() {
        if (this.data.length < 4) {
            throw new Error('Cannot readInt() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(4));
        return buf.readInt32LE();
    }
    writeIntLE(value) {
        const buf = Buffer.alloc(4);
        buf.writeInt32LE(value);
        this.writeByte(...buf);
    }
    readUIntBE() {
        if (this.data.length < 4) {
            throw new Error('Cannot readInt() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(4));
        return buf.readUInt32BE();
    }
    writeUIntBE(value) {
        const buf = Buffer.alloc(4);
        buf.writeUInt32BE(value);
        this.writeByte(...buf);
    }
    readUIntLE() {
        if (this.data.length < 4) {
            throw new Error('Cannot readInt() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(4));
        return buf.readUInt32LE();
    }
    writeUIntLE(value) {
        const buf = Buffer.alloc(4);
        buf.writeUInt32LE(value);
        this.writeByte(...buf);
    }
    readLongBE() {
        if (this.data.length < 8) {
            throw new Error('Cannot readInt() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(8));
        return buf.readBigInt64BE();
    }
    writeLongBE(value) {
        const buf = Buffer.alloc(8);
        buf.writeBigInt64BE(value);
        this.writeByte(...buf);
    }
    readLongLE() {
        if (this.data.length < 8) {
            throw new Error('Cannot readInt() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(8));
        return buf.readBigInt64LE();
    }
    writeLongLE(value) {
        const buf = Buffer.alloc(8);
        buf.writeBigInt64LE(value);
        this.writeByte(...buf);
    }
    readULongBE() {
        if (this.data.length < 8) {
            throw new Error('Cannot readInt() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(8));
        return buf.readBigUInt64BE();
    }
    writeULongBE(value) {
        const buf = Buffer.alloc(8);
        buf.writeBigUInt64BE(value);
        this.writeByte(...buf);
    }
    readULongLE() {
        if (this.data.length < 8) {
            throw new Error('Cannot readInt() as buffer is empty or too small for type');
        }
        const buf = Buffer.from(this.readBytes(8));
        return buf.readBigUInt64LE();
    }
    writeULongLE(value) {
        const buf = Buffer.alloc(8);
        buf.writeBigUInt64LE(value);
        this.writeByte(...buf);
    }
    readVarInt() {
        let numRead = 0;
        let result = 0;
        let read, value;
        do {
            if (numRead > 4) {
                throw new Error('VarInt exceeds data bounds');
            }
            read = this.readByte();
            value = (read & 0b01111111);
            result |= (value << (7 * numRead));
            numRead++;
            if (numRead > 5) {
                throw new Error('VarInt is too big');
            }
        } while ((read & 0b10000000) != 0);
        return result;
    }
    writeVarInt(value) {
        do {
            let temp = value & 0b01111111;
            value >>>= 7;
            if (value != 0) {
                temp |= 0b10000000;
            }
            this.writeByte(temp);
        } while (value != 0);
    }
    readString() {
        const length = this.readVarInt();
        return String.fromCodePoint(...this.data.splice(0, length));
    }
    writeString(value, writeLength) {
        if (writeLength) {
            this.writeVarInt(value.length);
        }
        for (let i = 0; i < value.length; i++) {
            this.writeByte(value.codePointAt(i) || 0);
        }
    }
    readStringNT() {
        let read, result = '';
        while ((read = this.readByte()) !== 0) {
            result += String.fromCodePoint(read);
        }
        return result;
    }
    writeStringNT(value) {
        for (let i = 0; i < value.length; i++) {
            this.writeByte(value.codePointAt(i) || 0);
        }
        this.writeByte(0);
    }
}
exports.default = Packet;
